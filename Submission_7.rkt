#lang rosette
(require racket/match)
(require rosette/lib/synthax)
(define-namespace-anchor anc)
(define ns (namespace-anchor->namespace anc))
(require racket/include)
(include "ults.rkt")
(provide simplify-exp)

;; ----------------------------------------------------------------------------
;;                                    Our Code
;; ----------------------------------------------------------------------------
;; Our make-rosette-simple function
;(define (make-rosette-simple formula) (make-rosette-simple formula (compute-height (syntax->datum formula) 0))) 
(define (make-rosette-simple formula depth) (begin (printf "Trying at depth ~a ...\n" depth)(append
                                       (generate-declarations (determineType (instance-types formula)))
                                       (list (list
                                              'synthesize
                                              '#:forall (append (list (quote list)) (getvars formula))
                                              '#:guarantee (quasiquote(assert (eq?
                                                                                (unquote formula)
                                                                                (unquote (skeleton-expression formula depth)))))))
                                       )))
;; Alt to make-sosette-simple that allows us to output solution
(define (print-solution formula depth) (append gen-exp-text
                                        (generate-declarations (determineType (instance-types formula)))
                                        (list (quasiquote (define (unquote (append(list (quote gen)) (getvars formula)))
                                                      (unquote (append (list (quote gen-expression))
                                                                       (list (get-booleans formula))
                                                                       (list (get-integers formula))
                                                                       (list (get-constants formula))
                                                                       (list depth))))
                                                      ))
                                        (list (quasiquote (syntax->datum (car(generate-forms
                                                           (unquote (list
                                                                    'synthesize
                                                                    '#:forall (append (list (quote list)) (getvars formula))
                                                                    '#:guarantee (quasiquote(assert (eq?
                                                                                                     (unquote formula)
                                                                                                     (unquote (skeleton-expression-print formula))))))))))
                                                          ) ";")))
;; Evaluates the series of expressions generated by make-rosette-simple
(define (eval-exp expr)(eval (append '(begin) expr)ns))
;; Our define-synthax function
(define-synthax(gen-expression (booleanvariables ...) (integervariables ...) (integerconstants ...) height)
 #:base (choose #t #f booleanvariables ... integervariables ... integerconstants ...)
 #:else (choose
         #t #f booleanvariables ... integervariables ... integerconstants ...
          ((choose = >= > <= < + - min max equal?) (gen-expression (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1))
                                                         (gen-expression (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1)))
          ((choose && ||) (gen-expression-weaker (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1))
                                                         (gen-expression-weaker (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1)))
          ((choose add1 sub1 !) (gen-expression (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1)))
          (if (gen-expression-weaker (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1))
              (gen-expression (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1))
              (gen-expression (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1)))
          )
  )
(define-synthax(gen-expression-weaker (booleanvariables ...) (integervariables ...) (integerconstants ...) height)
 #:base (choose booleanvariables ... integervariables ...)
 #:else (choose booleanvariables ... integervariables ... 
          ((choose = >= > <= < + - min max equal?) (gen-expression (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1))
                                                         (gen-expression (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1)))
          ((choose && ||) (gen-expression-weaker (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1))
                                                         (gen-expression-weaker (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1)))
          ((choose add1 sub1 !) (gen-expression (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1)))
          (if (gen-expression-weaker (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1))
              (gen-expression (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1))
              (gen-expression (booleanvariables ...)  (integervariables ...) (integerconstants ...) (- height 1)))
          )
  )
;; Starting with the height of the given formula, repeatedly attempts to synthesize the formula with
;; decreasing depth until we get an unsat. Returns the synthesis with the lowest depth
(define (simplify-exp expr)(begin (printf "Expression to simplify: ~a \n" (syntax->datum expr))
                                  (define simp-exp (manual_simplification expr))
                                  (printf "Manual simplification complete: ~a \n" simp-exp)
                                  (generateWarnings (manual_simplification expr))
                                  (if (list? simp-exp)
                                      (begin
                                        (simplify-exp-rec simp-exp 0)
                                        (print-to-file-and-get-solution))
                                      simp-exp)))
(define (simplify-exp-rec expr n)(if (and (!(>= n (compute-height expr 0))) (unsat? (eval-exp (make-rosette-simple expr n))))
                                     (simplify-exp-rec expr (+ n 1))
                                     (begin (printf "Success at ~a!!\n" n)(output-prep)(output-rosette-to-file(print-solution expr n)))
                                     )
  )

;; Write rosette-simple to a file
;(define (outputRossette ros-simple) (display ros-simple (open-output-file "data.txt")))
(define (output-rosette-to-file ros-simple)(call-with-output-file
                                       "data.rkt"#:exists 'append
                                     (lambda (out) (display ros-simple out))))
(define (output-prep)(call-with-output-file
                                       "data.rkt"#:exists 'truncate
                                     (lambda (out) (display ";" out))))
;; Generates a skeleton expression for use by make-rosette-simple and print-solution.
;; Currently just extracts the outermost operator in the formula and applies it to
;; 2 gen-expression calls
(define (skeleton-expression formula depth) (quasiquote(unquote (append (list (quote gen-expression))
                                                                         (list (get-booleans formula))
                                                                         (list (get-integers formula))
                                                                         (list (get-constants formula))
                                                                         (list depth)))))
(define (skeleton-expression-print formula) (quasiquote(unquote (append (list (quote gen))
                                                                        (get-booleans formula)
                                                                        (get-integers formula)))))

;; ----------------
;;  Type Inference
;; ----------------
;; A helper function to improve on make-all-rosette-decl, using our improved type
;; inferences. Generates the declarations of all variables in the function
(define (generate-declarations variables) (if (null? variables)
                                              (list)
                                              (append (list (list 'define-symbolic (second (car variables)) (car (car variables))))
                                                      (generate-declarations (rest variables)))))
;; A helper function that lists the inferred types of all instances of all variables in the given formula.
;; Variables may appear more than once with different inferred types - other helper functions analyze
;; these types and determine what type each variable should ultimately be assigned
(define (instance-types formula) (process-elements (rest formula) (optype? (car formula))))
(define (process-elements elements type) (if (null? elements)
                                               (list)
                                               (if (list? (car elements))
                                                   (append (instance-types (car elements)) (check-if-case elements type))
                                                   (if (or (number? (car elements)) (boolean? (car elements)))
                                                       (check-if-case elements type)
                                                       (if (eq? type 'both?)
                                                           (append (list (list 'boolean? (car elements))) (check-if-case elements type))
                                                           (append (list (list type (car elements))) (check-if-case elements type)))))))
;; acounts for the if case - first one is a boolean the rest are void.
(define (check-if-case elements type)(if (eq? type 'both?)
                                        (process-elements (rest elements) 'void?)
                                        (process-elements (rest elements) type)
                                        )
  )
;; Infers the types of all variables in the formula
(define (determineType lst) (determineTypeHelp
                             (remove-duplicates lst)
                             (remove-duplicates lst)))
(define (determineTypeHelp lst fullLst)(if (empty? lst)
                                           '()
                                           (append
                                            (if (isValid (car lst)(cdr lst))
                                                (if(isVoid (car lst) fullLst)
                                                   (list(append (list 'integer?) (cdr (car lst))))
                                                   (if (equal? (car (car lst)) 'void?)
                                                       '()
                                                       (list(car lst))
                                                       )
                                                   )
                                                (raise 'failed #t)
                                                )
                                            (determineTypeHelp (cdr lst) fullLst))
                                           ))
;; ------------------
;;  Variable Parsing
;; ------------------
;; A helper function that takes the given formula and returns a list of variables
(define (getvars lst)
  (remove-duplicates (filter notinteger (removeops lst)))
  )
;; A helper function that returns a list of all the boolean variables in a formula
(define (get-booleans formula) (parse-booleans (generate-declarations (determineType (instance-types formula)))))
(define (parse-booleans variables) (if (null? variables)
                                           (list)
                                           (if (eq?(third (car variables)) 'integer?)
                                               (parse-booleans (rest variables))
                                               (append (list (second (car variables)))
                                                       (parse-booleans (rest variables))))
                                           ))
;; A helper function that returns a list of all the integer variables in a formula
(define (get-integers formula) (parse-integers (generate-declarations (determineType (instance-types formula)))))
(define (parse-integers variables) (if (null? variables)
                                           (list)
                                           (if (eq?(third (car variables)) 'boolean?)
                                               (parse-integers (rest variables))
                                               (append (list (second (car variables)))
                                                       (parse-integers (rest variables))))
                                           ))
;; A helper function that returns a list of all the integer constants in a formula
(define (get-constants formula) (remove-duplicates (build-constant-list (flat-list formula))))
(define (build-constant-list formula) (if (null? formula)
                                          (list)
                                          (if (number? (car formula))
                                              (append (list (car formula)) (build-constant-list (rest formula)))
                                              (build-constant-list (rest formula)))))

(define (generateWarnings formula) (generateWarningsHelp (instance-types formula) (instance-types formula)))
(define (generateWarningsHelp lst fullList) (if (not (null? lst))
                                                (if (not (successfulInference (cdr (car lst)) fullList))
                                                    (begin (printf "Warning: we are assuming that ~a is an integer\n" (cdr (car lst)))
                                                           (generateWarningsHelp (rest lst) fullList))
                                                    (generateWarningsHelp (rest lst) fullList))
                                                (values)
                                                ))
(define (successfulInference variable lst) (if (null? lst)
                                                    #f
                                                    (if (and (eq? variable (cdr (car lst))) (not (eq? (car (car lst)) 'void?)))
                                                        #t
                                                        (successfulInference variable (rest lst)))))
;; -------------------
;;  Utility Functions
;; -------------------
(define (isVoid item lst)(if (equal? (car item) 'void?)
                             (andmap (lambda (item2) (or (equal? (car item2) (car item))
                                                          (!(equal? (cdr item2) (cdr item))))) lst)
                             #f))
(define (isValid item lst) (andmap (lambda (item2)
                                                 (if (equal? (cdr item) (cdr item2))
                                                     (or (equal? (car item) 'void?)
                                                         (equal? (car item2) 'void?))
                                                     #t
                                                     ))
                                               lst))
;; A helper function that computes the height of the expression
(define (compute-height formula height) (if (list? formula)
                                            (listmax (map (lambda (f) (compute-height f (+ 1 height))) formula))
                                            height))
(define (listmax lst) (if (null? lst)
                          0
                          (max (car lst) (listmax (rest lst)))))
(define (notinteger i)
  (cond
   [(integer? i) #f]
   [else #t])
  )
(define (flat-list lst)
  (cond ((null? lst) '())
        ((pair? lst)
         (append (flat-list (car lst))
                 (flat-list (cdr lst))))
        (else
         (list lst))))
(define (removeops lst)
 (remove* (list '+ '- 'or 'and 'min 'max '>= '> '< '<= '== '! '= 'if 'equal? '%top '#t '#f 'add1 'sub1) (flat-list lst)))

(define (print-to-file-and-get-solution) (begin (system "Racket data.rkt > solution.txt")
                              (define solution (file->syntax "solution.txt"))
                              (pretty-print (syntax->datum solution))))

;; -----------------------------
;;  Manual Simplification Rules
;; -----------------------------

(define (manual_simplification formula) (simplification_rules (syntax->datum formula)))

(define (simplification_rules formula) (if (and (list? formula))
                                           (case (car formula)
                                             ['+ (if (or (and (not (list? (second formula))) (list? (third formula)))
                                                         (and (not (list? (third formula))) (list? (second formula))))
                                                     (if (list? (second formula)) (simplify_addition_cancelation (third formula)
                                                                                                                 (simplification_rules (second formula)))
                                                         (simplify_addition_cancelation (second formula)
                                                                                        (simplification_rules (third formula))))
                                                     (simplify_addition (simplification_rules (second formula))
                                                                    (simplification_rules (third formula))))]
                                             ['- (simplify_subtraction (simplification_rules (second formula))
                                                                       (simplification_rules (third formula)))]
                                             ['> (if (and (equal? (car (second formula)) '+) (equal? (car (second formula)) '+))
                                                     (simplify_comparison_identical (simplification_rules (second formula))
                                                                              (simplification_rules (third formula))
                                                                              '>)
                                                     (simplify_greater_than (simplification_rules (second formula)) 
                                                                            (simplification_rules (third formula))))]
                                             ['< (if (and (equal? (car (second formula)) '+) (equal? (car (second formula)) '+))
                                                     (simplify_comparison_identical (simplification_rules (second formula))
                                                                              (simplification_rules (third formula))
                                                                              '<)
                                                     (simplify_less_than (simplification_rules (second formula))
                                                                         (simplification_rules (third formula))))]
                                             ['>= (if (and (equal? (car (second formula)) '+) (equal? (car (second formula)) '+))
                                                     (simplify_comparison_identical (simplification_rules (second formula))
                                                                              (simplification_rules (third formula))
                                                                              '>=)
                                                     (simplify_greater_than_eq (simplification_rules (second formula))
                                                                               (simplification_rules (third formula))))]
                                             ['<= (if (and (equal? (car (second formula)) '+) (equal? (car (second formula)) '+))
                                                     (simplify_comparison_identical (simplification_rules (second formula))
                                                                              (simplification_rules (third formula))
                                                                              '<=)
                                                     (simplify_less_than_eq (simplification_rules (second formula))
                                                                            (simplification_rules (third formula))))]
                                             ['== (simplify_double_equal (simplification_rules (second formula))
                                                                         (simplification_rules (third formula)))]
                                             ['min (simplify_min (simplification_rules (second formula))
                                                                 (simplification_rules (third formula)))]
                                             ['max (simplify_max (simplification_rules (second formula))
                                                                 (simplification_rules (third formula)))]
                                             [(not !) (simplify_not (simplification_rules (second formula)))]
                                             [(or ||) (simplify_or (simplification_rules (second formula))
                                                                   (simplification_rules (third formula)))]
                                             [(and &&) (simplify_and (simplification_rules (second formula))
                                                                     (simplification_rules (third formula)))]
                                             ['= (simplify_equal (simplification_rules (second formula))
                                                                 (simplification_rules (third formula)))]
                                             ['if (simplify_if (simplification_rules (second formula))
                                                               (simplification_rules (third formula))
                                                               (simplification_rules (fourth formula)))]
                                             [else formula])
                                           formula))

(define (simplify_addition arg1 arg2) (if (eq? arg1 0)
                                          arg2
                                          (if (eq? arg2 0)
                                              arg1
                                              (list '+ arg1 arg2))))

(define (simplify_addition_cancelation arg1 arg2) (if (number? arg1)
                                                      (if (member (- 0 arg1) arg2)
                                                          (list (second (remove (- 0 arg1) arg2)))
                                                          (list '+ arg1 arg2))
                                                      (list '+ arg1 arg2)))

(define (simplify_subtraction arg1 arg2) (if (eq? arg2 0)
                                             arg1
                                             (list '- arg1 arg2)))

(define (simplify_greater_than arg1 arg2) (if (eq? arg1 arg2)
                                              #f
                                              (list '> arg1 arg2)))

(define (simplify_less_than arg1 arg2) (if (eq? arg1 arg2)
                                           #f
                                           (list '< arg1 arg2)))

(define (simplify_greater_than_eq arg1 arg2) (if (eq? arg1 arg2)
                                                 #t
                                                 (list '>= arg1 arg2)))

(define (simplify_less_than_eq arg1 arg2) (if (eq? arg1 arg2)
                                              #t
                                              (list '<= arg1 arg2)))


(define (simplify_comparison_identical arg1 arg2 operator) (if (and (list? arg1) (list? arg2))
                                                (if (member (second arg1) arg2)
                                                    (list operator (second (remove (second arg1) arg1)) (second(remove (second arg1) arg2)))
                                                    (if (member (third arg1) arg2)
                                                        (list operator (second (remove (third arg1) arg1)) (second (remove (third arg1) arg2)))
                                                        (list operator arg1 arg2)
                                                        )
                                                )
                                                (list '< arg1 arg2)))

(define (simplify_double_equal arg1 arg2) (list '= arg1 arg2))

(define (simplify_min arg1 arg2) (list 'min arg1 arg2))

(define (simplify_max arg1 arg2) (list 'max arg1 arg2))

(define (simplify_not arg1) (if (eq? arg1 #t)
                                #f
                                (if (eq? arg1 #f)
                                    #t
                                    (list '! arg1))))

(define (simplify_or arg1 arg2) (if (or (eq? arg1 #t) (eq? arg2 #t))
                                    #t
                                    (if (and (eq? arg1 #f) (eq? arg2 #f))
                                        #f
                                        (list 'or arg1 arg2))))

(define (simplify_and arg1 arg2) (if (or (eq? arg1 #f) (eq? arg2 #f))
                                    #f
                                    (if (and (eq? arg1 #t) (eq? arg2 #t))
                                        #t
                                        (list 'and arg1 arg2))))

(define (simplify_equal arg1 arg2) (list 'equal? arg1 arg2))

(define (simplify_if arg1 arg2 arg3) (if (equal? arg2 arg3) arg3 (list 'if arg1 arg2 arg3)))